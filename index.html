<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Live Transcribe & Translate</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background: #f7f7f7;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      }

      h1 {
        text-align: center;
        margin: 20px 0 10px;
      }

      #toggleBtn {
        padding: 10px 20px;
        margin: 10px 0 20px;
        border: none;
        border-radius: 6px;
        background: #111827;
        color: white;
        cursor: pointer;
        font-size: 16px;
      }
      #toggleBtn:hover {
        background: #0056b3;
      }

      .container {
        display: flex;
        justify-content: center;
        gap: 40px;
        width: 90%;
        max-width: 1000px;
      }

      .panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        padding: 15px;
      }

      .panel select {
        margin-bottom: 10px;
        padding: 6px;
        border-radius: 4px;
        border: 1px solid #ccc;
        font-size: 14px;
      }

      .panel h2 {
        text-align: center;
        margin: 10px 0;
      }

      .content-box {
        flex: 1;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 10px;
        background: #fafafa;
        font-size: 14px;
      }

      #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 20px 0;
      }

      #playTTSBtn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        background: #28a745;
        color: white;
        cursor: pointer;
        margin-bottom: 10px;
      }
      #playTTSBtn:hover {
        background: #1e7e34;
      }

      #ttsAudio {
        width: 300px;
      }

      #status {
        text-align: center;
        margin: 15px 0;
        font-style: italic;
        color: #555;
      }
    </style>
  </head>
  <body>
    <h1>Live Transcribe & Translate</h1>
    <button id="toggleBtn">Start</button>

    <div class="container">
      <!-- Transcription Panel -->
      <div class="panel">
        <select id="speakerLangSelect">
          <option value="">Auto-detect</option>
          <option value="en">English</option>
          <option value="ur">Urdu</option>
          <option value="es">Spanish</option>
          <!-- add more if needed-->
        </select>
        <h2>Transcription</h2>
        <div id="original" class="content-box"></div>
      </div>

      <!-- Translation Panel -->
      <div class="panel">
        <select id="listenerLangSelect">
          <option value="en">English</option>
          <option value="ur">Urdu</option>
          <option value="es">Spanish</option>
          <!-- add more -->
        </select>
        <h2>Translation</h2>
        <div id="translated" class="content-box">
          Translation will appear here
        </div>
      </div>
    </div>

    <div id="controls">
      <button id="playTTSBtn" disabled>ðŸ”Š Play Translation</button>
      <audio id="ttsAudio" controls></audio>
    </div>

    <div id="status"></div>

    <script>
      
      const toggleBtn = document.getElementById("toggleBtn");
      const statusEl = document.getElementById("status");
      const originalEl = document.getElementById("original");
      const translatedEl = document.getElementById("translated");
      const speakerLangSelect = document.getElementById("speakerLangSelect");
      const listenerLangSelect = document.getElementById("listenerLangSelect");
      const playTTSBtn = document.getElementById("playTTSBtn");
      const ttsAudio = document.getElementById("ttsAudio");
      const CHUNK_MS = 5000;

      let audioStream = null;
      let mediaRecorder = null;
      let chunkCounter = 0;

      let running = false; 
      let fullTranscript = ""; 
      let chunkQueue = []; 

      let processingQueue = false; 
      let drainResolver = null; 

      async function translateTranscript(text, targetLang) {
        const form = new FormData();
        form.append("text", text);
        form.append("language", targetLang);

        const res = await fetch("https://voice-ai-app-skys.onrender.com/translate", {
          method: "POST",
          body: form,
        });

        if (!res.ok) throw new Error(await res.text());
        const j = await res.json();
        return j.translated;
      }

      async function fetchTTS(text) {
        const form = new FormData();
        form.append("text", text);

        const res = await fetch("https://voice-ai-app-skys.onrender.com/speak", {
          method: "POST",
          body: form,
        });

        if (!res.ok) throw new Error(await res.text());
        const blob = await res.blob();
        return URL.createObjectURL(blob);
      }

      async function handleTTS() {
        const text = (translatedEl.textContent || "").trim();
        if (!text) return;
        statusEl.textContent = "Generating speech...";
        playTTSBtn.disabled = true;
        try {
          const url = await fetchTTS(text);
          ttsAudio.src = url;
          await ttsAudio.play().catch(() => {
          });
          statusEl.textContent = "Speech ready";
        } catch (err) {
          console.error("TTS error:", err);
          statusEl.textContent = "TTS error";
        } finally {
          playTTSBtn.disabled = false;
        }
      }

      async function processChunkQueueWorker() {
        if (processingQueue) return; // already running
        processingQueue = true;

        while (chunkQueue.length > 0) {
          const form = chunkQueue.shift();
          try {
            const res = await fetch("https://voice-ai-app-skys.onrender.com/transcribe-chunk", {
              method: "POST",
              body: form,
            });

            if (!res.ok) {
              const text = await res.text();
              console.error("Transcribe chunk server error:", text);
              statusEl.textContent = "Server error (chunk)";
              continue;
            }

            const j = await res.json();
            const chunkText = (j.text || "").trim();

            if (chunkText) {
              const p = document.createElement("p");
              p.textContent = chunkText;
              originalEl.appendChild(p);
              originalEl.scrollTop = originalEl.scrollHeight;

              fullTranscript += (fullTranscript ? " " : "") + chunkText;
            }

            statusEl.textContent = `Listening â€” model: ${j.model || "unknown"}`;
          } catch (err) {
            console.error("Chunk upload error:", err);
            statusEl.textContent = "Network error (chunk)";
          }
        }

        processingQueue = false;

        if (typeof drainResolver === "function") {
          const r = drainResolver;
          drainResolver = null;
          r();
        }
      }

      async function startRecording() {
        try {
          audioStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
        } catch (err) {
          alert("Microphone permission required: " + err.message);
          return;
        }

        originalEl.innerHTML = "";
        translatedEl.textContent = "Translation will appear here shortly.";
        translatedEl.style.opacity = "0.5";
        playTTSBtn.disabled = true;

        chunkCounter = 0;
        fullTranscript = "";
        chunkQueue = [];
        drainResolver = null;
        processingQueue = false;
        running = true;

        statusEl.textContent = "Recording...";
        recordNextChunk();
      }

      function recordNextChunk() {
        if (!running) return;

        try {
          mediaRecorder = new MediaRecorder(audioStream, {
            mimeType: "audio/webm;codecs=opus",
          });
        } catch (err) {
          console.error("MediaRecorder creation failed:", err);
          statusEl.textContent = "Recorder error";
          running = false;
          return;
        }

        mediaRecorder.addEventListener("dataavailable", (ev) => {
          if (!ev.data || ev.data.size < 200) return; // ignore tiny blobs

          const blob = new Blob([ev.data], { type: "audio/webm;codecs=opus" });
          const file = new File([blob], `chunk-${chunkCounter++}.webm`, {
            type: "audio/webm;codecs=opus",
          });

          const form = new FormData();
          form.append("audio", file);

          const speakerLanguage =
            speakerLangSelect && speakerLangSelect.value
              ? speakerLangSelect.value
              : "";
          if (speakerLanguage) form.append("language", speakerLanguage);

          chunkQueue.push(form);

          processChunkQueueWorker().catch((err) => {
            console.error("processChunkQueueWorker error:", err);
          });
        });

        mediaRecorder.addEventListener("stop", () => {
          mediaRecorder = null;
          if (running) {
            setTimeout(recordNextChunk, 50);
          } else {
          }
        });

        try {
          mediaRecorder.start();
        } catch (err) {
          console.error("mediaRecorder.start() failed:", err);
          statusEl.textContent = "Recorder error";
          running = false;
          return;
        }

        setTimeout(() => {
          if (mediaRecorder && mediaRecorder.state === "recording") {
            try {
              mediaRecorder.stop();
            } catch (e) {
            }
          }
        }, CHUNK_MS);
      }

      async function stopRecording() {
        running = false;

        if (mediaRecorder && mediaRecorder.state === "recording") {
          try {
            mediaRecorder.stop();
          } catch (e) {
          }
        }

        if (chunkQueue.length > 0 || processingQueue) {
          await new Promise((resolve) => {
            if (!processingQueue && chunkQueue.length === 0) {
              resolve();
              return;
            }
            drainResolver = resolve;
          });
        }

        if (audioStream) {
          audioStream.getTracks().forEach((t) => t.stop());
        }
        mediaRecorder = null;
        audioStream = null;

        if (!fullTranscript.trim()) {
          statusEl.textContent = "No transcript to translate";
          translatedEl.textContent = "";
          translatedEl.style.opacity = "0.5";
          playTTSBtn.disabled = true;
          return;
        }

        statusEl.textContent = "Preparing to translate";
        setTimeout(async () => {
          const listenerLang =
            listenerLangSelect && listenerLangSelect.value
              ? listenerLangSelect.value
              : "en";
          statusEl.textContent = "Translating...";
          translatedEl.textContent = "Translating...";
          translatedEl.style.opacity = "0.5";

          try {
            const translatedText = await translateTranscript(
              fullTranscript,
              listenerLang
            );
            translatedEl.textContent = translatedText;
            translatedEl.style.opacity = "1";
            statusEl.textContent = "Translation done";
            playTTSBtn.disabled = false;
          } catch (err) {
            console.error("Translation error:", err);
            translatedEl.textContent = "Translation failed.";
            statusEl.textContent = "Translation error";
            playTTSBtn.disabled = true;
          }
        }, 3000);
      }

      
      toggleBtn.addEventListener("click", () => {
        if (!running) {
          startRecording();
          toggleBtn.textContent = "Stop";
        } else {
          stopRecording().catch((err) => {
            console.error("stopRecording error:", err);
          });
          toggleBtn.textContent = "Start";
        }
      });

      playTTSBtn.addEventListener("click", handleTTS);
    </script>
  </body>
</html>
